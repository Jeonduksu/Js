<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>event</h1>
  <h3>고전 이벤트 모델(기본)</h3>
  <p>요소가 가지는 이벤트 속성에 핸들러를 연결하는 방법 </p>
  <button id="btn1">클릭</button>
  <button id="btn2">클릭!!</button>
  <script>
    let btn1 = document.getElementById("btn1");

    // 기존이벤트방식
    // 
    btn1.onclick = function(){
      alert("btn1이 클릭 되었습니다.")
    }

    // onclick = (e) 이벤트 객체
    document.getElementById("btn2").onclick=(e)=>{
      alert("btn2가 클릭 되었습니다.");
      console.log(window.event.target);
      // target 발생된이벤트 객체를 가져온다 쉽게 말해 속성값을 들고온다
      console.log(e.target);

      // 클릭의 속성값을 null 넣으면 아무것도 일어나지가 않는다
      // 약간 이벤트제거라고 생각하면된다
      btn1.onclick=null;
    }

  </script>
  <h3>인라인 이벤트 모델</h3>
  <p>요소 내부에 이벤트 속성으로써 실행할 내용을 작성하는 방식</p>
  <button onclick="test1();">클릭!</button>
  <script>
    function test1(){
      alert("인라인 이벤트 모델");
      // 자동으로 이벤트객체를 받아들이지않는다
      // console.log(e);
      // 이렇게 쓰면 받아들인다
      // console.log(window.event.target);
    }
  </script>

  <h3>표준 이벤트모델(addEventListener)</h3>
  <!-- 고정이벤트랑 매우 흡사하다 -->
  <button id="btn3">버튼!</button>
  <script>
    let btn3 = document.getElementById("btn3");

    btn3.addEventListener( "click", function(){
      alert("표준 이벤트 모델");
    } );

    btn3.addEventListener("mouseenter",function(e){
      alert("마우스 엔터");
      console.log(e.target);
    })
  </script>
</body>
</html>